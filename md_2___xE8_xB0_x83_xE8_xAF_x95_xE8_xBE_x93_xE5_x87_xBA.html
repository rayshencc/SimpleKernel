<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleKernel: 调试输出</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SimpleKernel<span id="projectnumber">&#160;1.17.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_2___xE8_xB0_x83_xE8_xAF_x95_xE8_xBE_x93_xE5_x87_xBA.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">调试输出</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md100"></a> </p>
<h1><a class="anchor" id="autotoc_md101"></a>
早期控制台 (Early Console)</h1>
<p>在内核启动的最早期（在此阶段，内存管理、中断甚至设备树解析都尚未完成），为了能够打印调试信息，SimpleKernel 提供了 Early Console 机制。</p>
<h2><a class="anchor" id="autotoc_md102"></a>
开启方式</h2>
<p>通过 CMake 预设变量 <code>SIMPLEKERNEL_EARLY_CONSOLE</code> 启用。该变量定义了串口控制器的物理基地址。</p>
<ul>
<li><b>x86_64</b>: 默认使用 COM1</li>
<li><b>RISC-V 64</b>: 0x10000000 (QEMU virt machine)</li>
<li><b>AArch64</b>: 0x9000000 (QEMU virt machine)</li>
</ul>
<h2><a class="anchor" id="autotoc_md103"></a>
实现机制</h2>
<p>利用 C++ 静态全局对象的构造函数在 <code>main</code> 函数之前执行的特性，<code>EarlyConsole</code> 类的构造函数会初始化一个最小可用的串口驱动，并设置 <code>sk_putchar</code> 函数指针，从而使得 <code>klog</code> 等日志函数能够立即工作。</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>EarlyConsole {</div>
<div class="line">  EarlyConsole() {</div>
<div class="line">    <span class="comment">// 初始化串口</span></div>
<div class="line">    <span class="comment">// 设置 console_putchar</span></div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment">// 静态实例，其构造函数会在 main 之前运行</span></div>
<div class="line">EarlyConsole early_console;</div>
</div><!-- fragment --><p>此阶段的串口驱动通常采用轮询模式，不依赖中断。</p>
<h1><a class="anchor" id="autotoc_md104"></a>
x86_64</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
概述</h2>
<p>x86_64 架构使用标准的串口（COM口）进行调试输出，主要基于16550 UART兼容的串口控制器。系统默认使用 COM1 端口（0x3F8）进行调试信息的输出。</p>
<h2><a class="anchor" id="autotoc_md106"></a>
关键组件</h2>
<h3><a class="anchor" id="autotoc_md107"></a>
1. Serial 类实现</h3>
<p>位于 <code>3rd/cpu_io/include/x86_64/cpu.hpp</code>，提供完整的串口通信功能：</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Serial {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> Serial(uint32_t port) : port_(port) {</div>
<div class="line">    <span class="comment">// 禁用所有中断</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 1, 0x00);</div>
<div class="line">    <span class="comment">// 启用 DLAB (设置波特率分频器)</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 3, 0x80);</div>
<div class="line">    <span class="comment">// 设置分频器为 3 (低字节) - 38400 波特率</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 0, 0x03);</div>
<div class="line">    <span class="comment">// 分频器高字节</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 1, 0x00);</div>
<div class="line">    <span class="comment">// 8位数据，无奇偶校验，1个停止位</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 3, 0x03);</div>
<div class="line">    <span class="comment">// 启用FIFO，清空缓冲区，14字节阈值</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 2, 0xC7);</div>
<div class="line">    <span class="comment">// 启用中断，设置RTS/DSR</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 4, 0x0B);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 自检测试</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 4, 0x1E);  <span class="comment">// 设置回环模式</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 0, 0xAE);   <span class="comment">// 发送测试字节</span></div>
<div class="line">    <span class="keywordflow">if</span> (In&lt;uint8_t&gt;(port_ + 0) != 0xAE) {</div>
<div class="line">      <span class="keyword">asm</span>(<span class="stringliteral">&quot;hlt&quot;</span>);  <span class="comment">// 串口故障，停机</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 设置正常操作模式</span></div>
<div class="line">    Out&lt;uint8_t&gt;(port_ + 4, 0x0F);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> Write(uint8_t <span class="keywordtype">byte</span>)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">while</span> (!IsTransmitEmpty()) { ; }</div>
<div class="line">    Out&lt;uint8_t&gt;(port_, <span class="keywordtype">byte</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  [[nodiscard]] <span class="keyword">auto</span> IsTransmitEmpty() const -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line">    <span class="keywordflow">return</span> bool((In&lt;uint8_t&gt;(port_ + 5) &amp; 0x20) != 0);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md108"></a>
2. 调试输出接口</h3>
<p>在 <code><a class="el" href="x86__64_2arch__main_8cpp.html">src/arch/x86_64/arch_main.cpp</a></code> 中实现输出函数：</p>
<div class="fragment"><div class="line"><span class="comment">// 基本输出实现</span></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line">cpu_io::Serial *serial = <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code hl_variable" href="sk__stdio_8h.html#a15ce3a1064b136eabaea65e2c7cee22e">sk_putchar</a>(<span class="keywordtype">int</span> c, [[maybe_unused]] <span class="keywordtype">void</span> *ctx) {</div>
<div class="line">  <span class="keywordflow">if</span> (serial) {</div>
<div class="line">    serial-&gt;Write(c);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="ask__stdio_8h_html_a15ce3a1064b136eabaea65e2c7cee22e"><div class="ttname"><a href="sk__stdio_8h.html#a15ce3a1064b136eabaea65e2c7cee22e">sk_putchar</a></div><div class="ttdeci">void(* sk_putchar)(int c, void *ctx)</div><div class="ttdef"><b>Definition</b> <a href="sk__stdio_8c_source.html#l00024">sk_stdio.c:24</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md109"></a>
初始化流程</h2>
<ol type="1">
<li>**串口初始化**：在 <code><a class="el" href="aarch64_2arch__main_8cpp.html#aa26c42c34bbb6c8c7cd4a8664dc7952f">ArchInit()</a></code> 中创建 Serial 实例 <div class="fragment"><div class="line"><a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;cpu_io::Serial&gt;::GetInstance</a>() = cpu_io::Serial(cpu_io::kCom1);</div>
<div class="line">serial = &amp;<a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;cpu_io::Serial&gt;::GetInstance</a>();</div>
<div class="ttc" id="aclassSingleton_html_a68856b49e098eadba37b60366db33ebd"><div class="ttname"><a href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton::GetInstance</a></div><div class="ttdeci">static auto GetInstance() -&gt; T &amp;</div><div class="ttdef"><b>Definition</b> <a href="singleton_8hpp_source.html#l00023">singleton.hpp:23</a></div></div>
</div><!-- fragment --></li>
<li>**端口配置**：<ul>
<li>COM1 端口地址：<code>0x3F8</code></li>
<li>波特率：38400 bps</li>
<li>数据位：8位</li>
<li>停止位：1位</li>
<li>奇偶校验：无</li>
<li>流控：硬件流控</li>
</ul>
</li>
<li>**自检验证**：通过回环测试确保串口正常工作</li>
</ol>
<h2><a class="anchor" id="autotoc_md110"></a>
寄存器定义</h2>
<div class="fragment"><div class="line"><span class="comment">// 串口寄存器偏移</span></div>
<div class="line"><span class="comment">// port + 0: 数据寄存器 (RHR/THR)</span></div>
<div class="line"><span class="comment">// port + 1: 中断使能寄存器 (IER)</span></div>
<div class="line"><span class="comment">// port + 2: FIFO控制寄存器 (FCR) / 中断状态寄存器 (ISR)</span></div>
<div class="line"><span class="comment">// port + 3: 线路控制寄存器 (LCR)</span></div>
<div class="line"><span class="comment">// port + 4: 调制解调器控制寄存器 (MCR)</span></div>
<div class="line"><span class="comment">// port + 5: 线路状态寄存器 (LSR)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t kCom1 = 0x3F8;  <span class="comment">// COM1端口基址</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md111"></a>
特性和优势</h2>
<ul>
<li>**硬件兼容性**：支持标准16550 UART</li>
<li>**可靠性**：包含硬件自检功能</li>
<li>**性能**：使用FIFO缓冲提高传输效率</li>
<li>**调试友好**：直接输出到主机串口终端</li>
</ul>
<h2><a class="anchor" id="autotoc_md112"></a>
使用示例</h2>
<div class="fragment"><div class="line"><span class="comment">// 初始化串口</span></div>
<div class="line"><span class="keyword">auto</span>&amp; serial = <a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;cpu_io::Serial&gt;::GetInstance</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 通过内核日志输出（会调用sk_putchar）</span></div>
<div class="line"><a class="code hl_struct" href="structklog_1_1Info.html">klog::Info</a>(<span class="stringliteral">&quot;Hello x86_64 Debug Output\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 直接串口写入</span></div>
<div class="line">serial.Write(<span class="charliteral">&#39;H&#39;</span>);</div>
<div class="line">serial.Write(<span class="charliteral">&#39;i&#39;</span>);</div>
<div class="ttc" id="astructklog_1_1Info_html"><div class="ttname"><a href="structklog_1_1Info.html">klog::Info</a></div><div class="ttdef"><b>Definition</b> <a href="kernel__log_8hpp_source.html#l00168">kernel_log.hpp:168</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md113"></a>
RISCV64</h1>
<h2><a class="anchor" id="autotoc_md114"></a>
概述</h2>
<p>RISC-V64 架构使用 OpenSBI 固件提供的调试控制台扩展 (Debug Console Extension) 进行调试输出。这种方式通过 SBI 调用直接与 Machine 模式固件通信，无需直接操作硬件串口。</p>
<h2><a class="anchor" id="autotoc_md115"></a>
关键组件</h2>
<h3><a class="anchor" id="autotoc_md116"></a>
1. SBI 调试控制台扩展</h3>
<p>基于 RISC-V SBI 标准的 Debug Console Extension (EID #0x4442434E "DBCN")：</p>
<div class="fragment"><div class="line"><span class="comment">// SBI 扩展ID和功能ID</span></div>
<div class="line"><span class="preprocessor">#define SBI_EXT_DBCN 0x4442434E</span></div>
<div class="line"><span class="preprocessor">#define SBI_EXT_DEBUG_CONSOLE_WRITE_BYTE 0x2</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>sbiret sbi_debug_console_write_byte(uint8_t byte);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md117"></a>
2. 调试输出接口</h3>
<p>在 <code><a class="el" href="riscv64_2arch__main_8cpp.html">src/arch/riscv64/arch_main.cpp</a></code> 中直接调用 SBI 接口：</p>
<div class="fragment"><div class="line"><span class="comment">// 基本输出实现</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code hl_variable" href="sk__stdio_8h.html#a15ce3a1064b136eabaea65e2c7cee22e">sk_putchar</a>(<span class="keywordtype">int</span> c, [[maybe_unused]] <span class="keywordtype">void</span> *ctx) {</div>
<div class="line">  sbi_debug_console_write_byte(c);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md118"></a>
SBI 调用机制</h2>
<h3><a class="anchor" id="autotoc_md119"></a>
1. SBI 调用实现</h3>
<p>SBI 调用通过 <code>ecall</code> 指令实现，具体在 <code>3rd/opensbi_interface/src/opensbi_interface.c</code>：</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>sbiret sbi_debug_console_write_byte(uint8_t byte) {</div>
<div class="line">  <span class="keywordflow">return</span> ecall(<span class="keywordtype">byte</span>, 0, 0, 0, 0, 0,</div>
<div class="line">               SBI_EXT_DEBUG_CONSOLE_WRITE_BYTE, SBI_EXT_DBCN);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 通用SBI调用函数</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>sbiret ecall(unsigned long arg0, unsigned long arg1,</div>
<div class="line">                                  unsigned long arg2, unsigned long arg3,</div>
<div class="line">                                  unsigned long arg4, unsigned long arg5,</div>
<div class="line">                                  unsigned long fid, unsigned long eid) {</div>
<div class="line">  <span class="keyword">struct </span>sbiret ret;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a0 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a0&quot;</span>) = arg0;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a1 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a1&quot;</span>) = arg1;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a2 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a2&quot;</span>) = arg2;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a3 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a3&quot;</span>) = arg3;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a4 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a4&quot;</span>) = arg4;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a5 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a5&quot;</span>) = arg5;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a6 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a6&quot;</span>) = fid;</div>
<div class="line">  <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> a7 <span class="keyword">asm</span>(<span class="stringliteral">&quot;a7&quot;</span>) = eid;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;ecall&quot;</span></div>
<div class="line">               : <span class="stringliteral">&quot;+r&quot;</span>(a0), <span class="stringliteral">&quot;+r&quot;</span>(a1)</div>
<div class="line">               : <span class="stringliteral">&quot;r&quot;</span>(a2), <span class="stringliteral">&quot;r&quot;</span>(a3), <span class="stringliteral">&quot;r&quot;</span>(a4), <span class="stringliteral">&quot;r&quot;</span>(a5), <span class="stringliteral">&quot;r&quot;</span>(a6), <span class="stringliteral">&quot;r&quot;</span>(a7)</div>
<div class="line">               : <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  ret.error = a0;</div>
<div class="line">  ret.value = a1;</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md120"></a>
2. 权限级别转换</h3>
<ul>
<li>**Supervisor 模式**：内核运行在 S 模式</li>
<li>**Machine 模式**：OpenSBI 固件运行在 M 模式</li>
<li>**调用流程**：S 模式 → <code>ecall</code> → M 模式 → 串口硬件</li>
</ul>
<h2><a class="anchor" id="autotoc_md121"></a>
初始化流程</h2>
<p>RISC-V64 的调试输出无需额外初始化，因为：</p>
<ol type="1">
<li>**固件支持**：OpenSBI 固件在启动时已初始化串口</li>
<li>**标准接口**：通过标准 SBI 调用访问</li>
<li>**自动配置**：固件根据设备树自动配置串口参数</li>
</ol>
<h2><a class="anchor" id="autotoc_md122"></a>
支持的SBI调试功能</h2>
<div class="fragment"><div class="line"><span class="comment">// 调试控制台扩展支持的功能</span></div>
<div class="line"><span class="preprocessor">#define SBI_EXT_DEBUG_CONSOLE_WRITE      0x0  </span><span class="comment">// 批量写入</span></div>
<div class="line"><span class="preprocessor">#define SBI_EXT_DEBUG_CONSOLE_READ       0x1  </span><span class="comment">// 批量读取</span></div>
<div class="line"><span class="preprocessor">#define SBI_EXT_DEBUG_CONSOLE_WRITE_BYTE 0x2  </span><span class="comment">// 单字节写入</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 错误码</span></div>
<div class="line"><span class="keyword">enum</span> {</div>
<div class="line">  SBI_SUCCESS = 0,</div>
<div class="line">  SBI_ERR_FAILED = -1,</div>
<div class="line">  SBI_ERR_NOT_SUPPORTED = -2,</div>
<div class="line">  SBI_ERR_INVALID_PARAM = -3,</div>
<div class="line">  SBI_ERR_DENIED = -4,</div>
<div class="line">  SBI_ERR_INVALID_ADDRESS = -5</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md123"></a>
特性和优势</h2>
<ul>
<li>**标准化**：基于 RISC-V SBI 标准</li>
<li>**简洁性**：无需硬件串口驱动</li>
<li>**可移植性**：适用于不同 RISC-V 实现</li>
<li>**固件管理**：串口配置由固件处理</li>
<li>**安全性**：通过固件统一管理硬件访问</li>
</ul>
<h2><a class="anchor" id="autotoc_md124"></a>
使用示例</h2>
<div class="fragment"><div class="line"><span class="comment">// 直接SBI调用</span></div>
<div class="line"><span class="keyword">auto</span> ret = sbi_debug_console_write_byte(<span class="charliteral">&#39;H&#39;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (ret.error != SBI_SUCCESS) {</div>
<div class="line">  <span class="comment">// 处理错误</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 通过内核日志输出（会调用sk_putchar）</span></div>
<div class="line"><a class="code hl_struct" href="structklog_1_1Info.html">klog::Info</a>(<span class="stringliteral">&quot;Hello RISC-V64 Debug Output\n&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md125"></a>
AARCH64</h1>
<h2><a class="anchor" id="autotoc_md126"></a>
概述</h2>
<p>AArch64 架构使用 ARM PrimeCell UART (PL011) 控制器进行调试输出。PL011 是 ARM 设计的标准 UART 控制器，广泛应用于 ARM 系统中，支持完整的 UART 功能和中断处理。</p>
<h2><a class="anchor" id="autotoc_md127"></a>
关键组件</h2>
<h3><a class="anchor" id="autotoc_md128"></a>
1. PL011 驱动实现</h3>
<p>位于 <code>src/driver/pl011/</code> 目录，提供完整的 PL011 UART 驱动：</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classPl011.html">Pl011</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> <a class="code hl_function" href="classPl011.html#a599a1f8c357ffbfcd510ceccca02a478">Pl011</a>(uint64_t dev_addr, uint64_t clock = 0, uint64_t baud_rate = 0);</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classPl011.html#a8efb16689d7e3353a36191861533090d">PutChar</a>(uint8_t c);</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// 寄存器偏移定义</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#ab67fcb3dc6d13002630e8b95957a4728">kRegDR</a> = 0x00;       <span class="comment">// 数据寄存器</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a5455e40a1d1c72649f8b2c0f61b9e66f">kRegRSRECR</a> = 0x04;   <span class="comment">// 接收状态/错误清除</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a62c476be5588db089e8e073f462b72e9">kRegFR</a> = 0x18;       <span class="comment">// 标志寄存器</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a0ba78229243d8c9f0a6d1c82e2caae7e">kRegIBRD</a> = 0x24;     <span class="comment">// 整数波特率分频器</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#ac27a7046c42eb9974e709f9d3b5e825c">kRegFBRD</a> = 0x28;     <span class="comment">// 小数波特率分频器</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a966e35597cb8894cc2ad7db9cb49556a">kRegLCRH</a> = 0x2C;     <span class="comment">// 线路控制寄存器</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a3832d758d909de71e6c634cdf1d21845">kRegCR</a> = 0x30;       <span class="comment">// 控制寄存器</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#ab0c74e0dbc67f8d891fae498930022cd">kRegIMSC</a> = 0x38;     <span class="comment">// 中断屏蔽设置/清除</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 控制位定义</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a5320acc79dd686839f46ae890d3c7932">kFRTxFIFO</a> = (1 &lt;&lt; 5);    <span class="comment">// 发送FIFO满</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#ab94062a057859a9ece9d5f278c13d868">kLCRHWlen8</a> = (3 &lt;&lt; 5);   <span class="comment">// 8位数据</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#abe6f8b3c55aee351229a192fb2d10eaf">kCREnable</a> = (1 &lt;&lt; 0);    <span class="comment">// UART使能</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a4d5c078dc81c6daee1e411c4ca78168c">kCRTxEnable</a> = (1 &lt;&lt; 8);  <span class="comment">// 发送使能</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#a779272949ea6561b812181c9a9c2f2aa">kCRRxEnable</a> = (1 &lt;&lt; 9);  <span class="comment">// 接收使能</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t <a class="code hl_variable" href="classPl011.html#ad02acf86a053eeaa821dd41eecd4d705">kIMSCRxim</a> = (1 &lt;&lt; 4);    <span class="comment">// 接收中断屏蔽</span></div>
<div class="line">};</div>
<div class="ttc" id="aclassPl011_html"><div class="ttname"><a href="classPl011.html">Pl011</a></div><div class="ttdoc">PL011 串口驱动</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00014">pl011.h:14</a></div></div>
<div class="ttc" id="aclassPl011_html_a0ba78229243d8c9f0a6d1c82e2caae7e"><div class="ttname"><a href="classPl011.html#a0ba78229243d8c9f0a6d1c82e2caae7e">Pl011::kRegIBRD</a></div><div class="ttdeci">static constexpr uint32_t kRegIBRD</div><div class="ttdoc">integer baud register</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00062">pl011.h:62</a></div></div>
<div class="ttc" id="aclassPl011_html_a3832d758d909de71e6c634cdf1d21845"><div class="ttname"><a href="classPl011.html#a3832d758d909de71e6c634cdf1d21845">Pl011::kRegCR</a></div><div class="ttdeci">static constexpr uint32_t kRegCR</div><div class="ttdoc">control register</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00068">pl011.h:68</a></div></div>
<div class="ttc" id="aclassPl011_html_a4d5c078dc81c6daee1e411c4ca78168c"><div class="ttname"><a href="classPl011.html#a4d5c078dc81c6daee1e411c4ca78168c">Pl011::kCRTxEnable</a></div><div class="ttdeci">static constexpr uint32_t kCRTxEnable</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00118">pl011.h:118</a></div></div>
<div class="ttc" id="aclassPl011_html_a5320acc79dd686839f46ae890d3c7932"><div class="ttname"><a href="classPl011.html#a5320acc79dd686839f46ae890d3c7932">Pl011::kFRTxFIFO</a></div><div class="ttdeci">static constexpr uint32_t kFRTxFIFO</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00091">pl011.h:91</a></div></div>
<div class="ttc" id="aclassPl011_html_a5455e40a1d1c72649f8b2c0f61b9e66f"><div class="ttname"><a href="classPl011.html#a5455e40a1d1c72649f8b2c0f61b9e66f">Pl011::kRegRSRECR</a></div><div class="ttdeci">static constexpr uint32_t kRegRSRECR</div><div class="ttdoc">receive status or error clear</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00052">pl011.h:52</a></div></div>
<div class="ttc" id="aclassPl011_html_a599a1f8c357ffbfcd510ceccca02a478"><div class="ttname"><a href="classPl011.html#a599a1f8c357ffbfcd510ceccca02a478">Pl011::Pl011</a></div><div class="ttdeci">Pl011()=default</div></div>
<div class="ttc" id="aclassPl011_html_a62c476be5588db089e8e073f462b72e9"><div class="ttname"><a href="classPl011.html#a62c476be5588db089e8e073f462b72e9">Pl011::kRegFR</a></div><div class="ttdeci">static constexpr uint32_t kRegFR</div><div class="ttdoc">flag register</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00058">pl011.h:58</a></div></div>
<div class="ttc" id="aclassPl011_html_a779272949ea6561b812181c9a9c2f2aa"><div class="ttname"><a href="classPl011.html#a779272949ea6561b812181c9a9c2f2aa">Pl011::kCRRxEnable</a></div><div class="ttdeci">static constexpr uint32_t kCRRxEnable</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00117">pl011.h:117</a></div></div>
<div class="ttc" id="aclassPl011_html_a8efb16689d7e3353a36191861533090d"><div class="ttname"><a href="classPl011.html#a8efb16689d7e3353a36191861533090d">Pl011::PutChar</a></div><div class="ttdeci">void PutChar(uint8_t c) const</div><div class="ttdef"><b>Definition</b> <a href="pl011_8cpp_source.html#l00035">pl011.cpp:35</a></div></div>
<div class="ttc" id="aclassPl011_html_a966e35597cb8894cc2ad7db9cb49556a"><div class="ttname"><a href="classPl011.html#a966e35597cb8894cc2ad7db9cb49556a">Pl011::kRegLCRH</a></div><div class="ttdeci">static constexpr uint32_t kRegLCRH</div><div class="ttdoc">line control register</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00066">pl011.h:66</a></div></div>
<div class="ttc" id="aclassPl011_html_ab0c74e0dbc67f8d891fae498930022cd"><div class="ttname"><a href="classPl011.html#ab0c74e0dbc67f8d891fae498930022cd">Pl011::kRegIMSC</a></div><div class="ttdeci">static constexpr uint32_t kRegIMSC</div><div class="ttdoc">interrupt mask set/clear</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00072">pl011.h:72</a></div></div>
<div class="ttc" id="aclassPl011_html_ab67fcb3dc6d13002630e8b95957a4728"><div class="ttname"><a href="classPl011.html#ab67fcb3dc6d13002630e8b95957a4728">Pl011::kRegDR</a></div><div class="ttdeci">static constexpr uint32_t kRegDR</div><div class="ttdoc">data register</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00050">pl011.h:50</a></div></div>
<div class="ttc" id="aclassPl011_html_ab94062a057859a9ece9d5f278c13d868"><div class="ttname"><a href="classPl011.html#ab94062a057859a9ece9d5f278c13d868">Pl011::kLCRHWlen8</a></div><div class="ttdeci">static constexpr uint32_t kLCRHWlen8</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00100">pl011.h:100</a></div></div>
<div class="ttc" id="aclassPl011_html_abe6f8b3c55aee351229a192fb2d10eaf"><div class="ttname"><a href="classPl011.html#abe6f8b3c55aee351229a192fb2d10eaf">Pl011::kCREnable</a></div><div class="ttdeci">static constexpr uint32_t kCREnable</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00121">pl011.h:121</a></div></div>
<div class="ttc" id="aclassPl011_html_ac27a7046c42eb9974e709f9d3b5e825c"><div class="ttname"><a href="classPl011.html#ac27a7046c42eb9974e709f9d3b5e825c">Pl011::kRegFBRD</a></div><div class="ttdeci">static constexpr uint32_t kRegFBRD</div><div class="ttdoc">fractional baud register</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00064">pl011.h:64</a></div></div>
<div class="ttc" id="aclassPl011_html_ad02acf86a053eeaa821dd41eecd4d705"><div class="ttname"><a href="classPl011.html#ad02acf86a053eeaa821dd41eecd4d705">Pl011::kIMSCRxim</a></div><div class="ttdeci">static constexpr uint32_t kIMSCRxim</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00124">pl011.h:124</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md129"></a>
2. 初始化实现</h3>
<div class="fragment"><div class="line"><a class="code hl_function" href="classPl011.html#a599a1f8c357ffbfcd510ceccca02a478">Pl011::Pl011</a>(uint64_t dev_addr, uint64_t clock, uint64_t baud_rate)</div>
<div class="line">    : base_addr_(dev_addr), base_clock_(clock), baud_rate_(baud_rate) {</div>
<div class="line">  <span class="comment">// 清除所有错误</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(base_addr_ + kRegRSRECR, 0);</div>
<div class="line">  <span class="comment">// 禁用所有功能</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(base_addr_ + kRegCR, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 设置波特率（如果提供了时钟和波特率）</span></div>
<div class="line">  <span class="keywordflow">if</span> (baud_rate_ != 0) {</div>
<div class="line">    uint32_t divisor = (base_clock_ * 4) / baud_rate_;</div>
<div class="line">    io::Out&lt;uint32_t&gt;(base_addr_ + kRegIBRD, divisor &gt;&gt; 6);</div>
<div class="line">    io::Out&lt;uint32_t&gt;(base_addr_ + kRegFBRD, divisor &amp; 0x3f);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 配置为8位数据，1个停止位，无奇偶校验，禁用FIFO</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(base_addr_ + kRegLCRH, kLCRHWlen8);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 启用接收中断</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(base_addr_ + kRegIMSC, kIMSCRxim);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 启用UART和收发功能</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(base_addr_ + kRegCR, kCREnable | kCRTxEnable | kCRRxEnable);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md130"></a>
3. 字符输出实现</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="classPl011.html#a8efb16689d7e3353a36191861533090d">Pl011::PutChar</a>(uint8_t c) {</div>
<div class="line">  <span class="comment">// 等待发送FIFO有空间或设备被禁用</span></div>
<div class="line">  <span class="keywordflow">while</span> (io::In&lt;uint32_t&gt;(<a class="code hl_variable" href="classPl011.html#a6f2f28cfc5311247057396f0544acebd">base_addr_</a> + <a class="code hl_variable" href="classPl011.html#a62c476be5588db089e8e073f462b72e9">kRegFR</a>) &amp; <a class="code hl_variable" href="classPl011.html#a5320acc79dd686839f46ae890d3c7932">kFRTxFIFO</a>) { ; }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 写入数据寄存器</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(<a class="code hl_variable" href="classPl011.html#a6f2f28cfc5311247057396f0544acebd">base_addr_</a> + <a class="code hl_variable" href="classPl011.html#ab67fcb3dc6d13002630e8b95957a4728">kRegDR</a>, c);</div>
<div class="line">}</div>
<div class="ttc" id="aclassPl011_html_a6f2f28cfc5311247057396f0544acebd"><div class="ttname"><a href="classPl011.html#a6f2f28cfc5311247057396f0544acebd">Pl011::base_addr_</a></div><div class="ttdeci">uint64_t base_addr_</div><div class="ttdef"><b>Definition</b> <a href="pl011_8h_source.html#l00126">pl011.h:126</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md131"></a>
4. 调试输出接口</h3>
<p>在 <code><a class="el" href="aarch64_2arch__main_8cpp.html">src/arch/aarch64/arch_main.cpp</a></code> 中实现：</p>
<div class="fragment"><div class="line"><span class="comment">// 基本输出实现</span></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"><a class="code hl_class" href="classPl011.html">Pl011</a> *pl011 = <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code hl_variable" href="sk__stdio_8h.html#a15ce3a1064b136eabaea65e2c7cee22e">sk_putchar</a>(<span class="keywordtype">int</span> c, [[maybe_unused]] <span class="keywordtype">void</span> *ctx) {</div>
<div class="line">  <span class="keywordflow">if</span> (pl011) {</div>
<div class="line">    pl011-&gt;<a class="code hl_function" href="classPl011.html#a8efb16689d7e3353a36191861533090d">PutChar</a>(c);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md132"></a>
设备树配置</h2>
<h3><a class="anchor" id="autotoc_md133"></a>
1. 串口信息获取</h3>
<p>通过设备树获取串口配置，在 <code><a class="el" href="kernel__fdt_8hpp.html">src/include/kernel_fdt.hpp</a></code> 中实现：</p>
<div class="fragment"><div class="line">[[nodiscard]] <span class="keyword">auto</span> GetSerial() const -&gt; <a class="code hl_namespace" href="namespacestd.html">std</a>::tuple&lt;uint64_t, <span class="keywordtype">size_t</span>, uint32_t&gt; {</div>
<div class="line">  <span class="comment">// 1. 查找 /chosen 节点</span></div>
<div class="line">  <span class="keywordtype">int</span> chosen_offset = fdt_path_offset(fdt_header_, <span class="stringliteral">&quot;/chosen&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 2. 获取 stdout-path 属性</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> *prop = fdt_get_property(fdt_header_, chosen_offset, <span class="stringliteral">&quot;stdout-path&quot;</span>, &amp;len);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *stdout_path = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(prop-&gt;data);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 3. 解析路径并查找对应的串口节点</span></div>
<div class="line">  <span class="keywordtype">int</span> stdout_offset = fdt_path_offset(fdt_header_, path_buffer.data());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 4. 获取寄存器基址和大小</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> *reg_prop = fdt_get_property(fdt_header_, stdout_offset, <span class="stringliteral">&quot;reg&quot;</span>, &amp;len);</div>
<div class="line">  uint64_t base = fdt64_to_cpu(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t *<span class="keyword">&gt;</span>(reg_prop-&gt;data)[0]);</div>
<div class="line">  <span class="keywordtype">size_t</span> size = fdt64_to_cpu(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint64_t *<span class="keyword">&gt;</span>(reg_prop-&gt;data)[1]);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 5. 获取中断号</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> *irq_prop = fdt_get_property(fdt_header_, stdout_offset, <span class="stringliteral">&quot;interrupts&quot;</span>, &amp;len);</div>
<div class="line">  uint32_t irq = fdt32_to_cpu(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint32_t *<span class="keyword">&gt;</span>(irq_prop-&gt;data)[1]);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {base, size, irq};</div>
<div class="line">}</div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition</b> <a href="resource__id_8hpp_source.html#l00135">resource_id.hpp:135</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md134"></a>
2. 典型设备树配置</h3>
<div class="fragment"><div class="line">/ {</div>
<div class="line">  chosen {</div>
<div class="line">    stdout-path = &quot;/uart@9000000&quot;;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  uart@9000000 {</div>
<div class="line">    compatible = &quot;arm,pl011&quot;, &quot;arm,primecell&quot;;</div>
<div class="line">    reg = &lt;0x0 0x9000000 0x0 0x1000&gt;;</div>
<div class="line">    interrupts = &lt;0x0 0x1 0x4&gt;;</div>
<div class="line">    clock-names = &quot;uartclk&quot;, &quot;apb_pclk&quot;;</div>
<div class="line">    clocks = &lt;&amp;clk24mhz&gt;, &lt;&amp;clk24mhz&gt;;</div>
<div class="line">  };</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md135"></a>
初始化流程</h2>
<p>在 <code><a class="el" href="aarch64_2arch__main_8cpp.html">src/arch/aarch64/arch_main.cpp</a></code> 的 <code><a class="el" href="aarch64_2arch__main_8cpp.html#aa26c42c34bbb6c8c7cd4a8664dc7952f">ArchInit()</a></code> 中：</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="aarch64_2arch__main_8cpp.html#aa26c42c34bbb6c8c7cd4a8664dc7952f">ArchInit</a>(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="comment">// 1. 解析设备树</span></div>
<div class="line">  <a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;KernelFdt&gt;::GetInstance</a>() =</div>
<div class="line">      <a class="code hl_class" href="classKernelFdt.html">KernelFdt</a>(<a class="code hl_define" href="sk__libc__test_8cpp.html#acbc25345a39784031ea891c317ab6f4e">strtoull</a>(argv[2], <span class="keyword">nullptr</span>, 16));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 2. 获取串口信息</span></div>
<div class="line">  <span class="keyword">auto</span> [serial_base, serial_size, irq] =</div>
<div class="line">      <a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;KernelFdt&gt;::GetInstance</a>().GetSerial();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 3. 初始化PL011串口</span></div>
<div class="line">  <a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;Pl011&gt;::GetInstance</a>() = <a class="code hl_class" href="classPl011.html">Pl011</a>(serial_base);</div>
<div class="line">  pl011 = &amp;<a class="code hl_function" href="classSingleton.html#a68856b49e098eadba37b60366db33ebd">Singleton&lt;Pl011&gt;::GetInstance</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 4. 串口现在可用于调试输出</span></div>
<div class="line">  <a class="code hl_struct" href="structklog_1_1Info.html">klog::Info</a>(<span class="stringliteral">&quot;Hello aarch64 ArchInit\n&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aaarch64_2arch__main_8cpp_html_aa26c42c34bbb6c8c7cd4a8664dc7952f"><div class="ttname"><a href="aarch64_2arch__main_8cpp.html#aa26c42c34bbb6c8c7cd4a8664dc7952f">ArchInit</a></div><div class="ttdeci">void ArchInit(int argc, const char **argv)</div><div class="ttdef"><b>Definition</b> <a href="aarch64_2arch__main_8cpp_source.html#l00047">arch_main.cpp:47</a></div></div>
<div class="ttc" id="aclassKernelFdt_html"><div class="ttname"><a href="classKernelFdt.html">KernelFdt</a></div><div class="ttdef"><b>Definition</b> <a href="kernel__fdt_8hpp_source.html#l00034">kernel_fdt.hpp:34</a></div></div>
<div class="ttc" id="ask__libc__test_8cpp_html_acbc25345a39784031ea891c317ab6f4e"><div class="ttname"><a href="sk__libc__test_8cpp.html#acbc25345a39784031ea891c317ab6f4e">strtoull</a></div><div class="ttdeci">#define strtoull</div><div class="ttdef"><b>Definition</b> <a href="sk__libc__test_8cpp_source.html#l00018">sk_libc_test.cpp:18</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md136"></a>
寄存器详解</h2>
<h3><a class="anchor" id="autotoc_md137"></a>
1. 核心寄存器</h3>
<div class="fragment"><div class="line"><span class="comment">// 数据寄存器 (DR) - 0x00</span></div>
<div class="line"><span class="comment">// 位[7:0]: 发送/接收数据</span></div>
<div class="line"><span class="comment">// 位[11:8]: 错误标志 (仅读取时)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 标志寄存器 (FR) - 0x18</span></div>
<div class="line"><span class="comment">// 位[7]: TXFE - 发送FIFO空</span></div>
<div class="line"><span class="comment">// 位[6]: RXFF - 接收FIFO满</span></div>
<div class="line"><span class="comment">// 位[5]: TXFF - 发送FIFO满</span></div>
<div class="line"><span class="comment">// 位[4]: RXFE - 接收FIFO空</span></div>
<div class="line"><span class="comment">// 位[3]: BUSY - UART忙</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 线路控制寄存器 (LCRH) - 0x2C</span></div>
<div class="line"><span class="comment">// 位[6:5]: WLEN - 字长选择 (11=8位)</span></div>
<div class="line"><span class="comment">// 位[4]: FEN - FIFO使能</span></div>
<div class="line"><span class="comment">// 位[1]: PEN - 奇偶校验使能</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 控制寄存器 (CR) - 0x30</span></div>
<div class="line"><span class="comment">// 位[9]: RXE - 接收使能</span></div>
<div class="line"><span class="comment">// 位[8]: TXE - 发送使能</span></div>
<div class="line"><span class="comment">// 位[0]: UARTEN - UART使能</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md138"></a>
2. 波特率设置</h3>
<div class="fragment"><div class="line"><span class="comment">// 波特率计算公式:</span></div>
<div class="line"><span class="comment">// BAUDDIV = (UARTCLK * 4) / BAUD_RATE</span></div>
<div class="line"><span class="comment">// IBRD = BAUDDIV &gt;&gt; 6</span></div>
<div class="line"><span class="comment">// FBRD = BAUDDIV &amp; 0x3F</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 例如: UARTCLK=24MHz, BAUD_RATE=115200</span></div>
<div class="line"><span class="comment">// BAUDDIV = (24000000 * 4) / 115200 = 833.33</span></div>
<div class="line"><span class="comment">// IBRD = 833 &gt;&gt; 6 = 13</span></div>
<div class="line"><span class="comment">// FBRD = 833 &amp; 0x3F = 1</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md139"></a>
特性和优势</h2>
<ul>
<li>**ARM标准**：符合ARM PrimeCell规范</li>
<li>**功能完整**：支持中断、FIFO、流控等</li>
<li>**设备树驱动**：通过设备树动态配置</li>
<li>**可扩展性**：支持多种波特率和配置</li>
<li>**调试友好**：与ARM开发工具兼容</li>
</ul>
<h2><a class="anchor" id="autotoc_md140"></a>
中断支持</h2>
<div class="fragment"><div class="line"><span class="comment">// 中断相关寄存器</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t kRegRIS = 0x3C;   <span class="comment">// 原始中断状态</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t kRegMIS = 0x40;   <span class="comment">// 屏蔽中断状态</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t kRegICR = 0x44;   <span class="comment">// 中断清除</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 中断类型</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t kIMSCRTIM = (1 &lt;&lt; 6);  <span class="comment">// 接收超时中断</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t kIMSCRxim = (1 &lt;&lt; 4);  <span class="comment">// 接收中断</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md141"></a>
使用示例</h2>
<div class="fragment"><div class="line"><span class="comment">// 初始化PL011串口</span></div>
<div class="line"><span class="keyword">auto</span> [base, size, irq] = GetSerial();</div>
<div class="line"><a class="code hl_class" href="classPl011.html">Pl011</a> <a class="code hl_variable" href="tests_2integration__test_2aarch64__minimal_2main_8cpp.html#aa7ab943a365e8ef56f90c192e7777452">uart</a>(base);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 直接字符输出</span></div>
<div class="line"><a class="code hl_variable" href="tests_2integration__test_2aarch64__minimal_2main_8cpp.html#aa7ab943a365e8ef56f90c192e7777452">uart</a>.PutChar(<span class="charliteral">&#39;H&#39;</span>);</div>
<div class="line"><a class="code hl_variable" href="tests_2integration__test_2aarch64__minimal_2main_8cpp.html#aa7ab943a365e8ef56f90c192e7777452">uart</a>.PutChar(<span class="charliteral">&#39;i&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 通过内核日志输出（会调用sk_putchar）</span></div>
<div class="line"><a class="code hl_struct" href="structklog_1_1Info.html">klog::Info</a>(<span class="stringliteral">&quot;Hello AArch64 Debug Output\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 检查串口状态</span></div>
<div class="line">uint32_t status = io::In&lt;uint32_t&gt;(base + <a class="code hl_variable" href="classPl011.html#a62c476be5588db089e8e073f462b72e9">Pl011::kRegFR</a>);</div>
<div class="line"><span class="keywordtype">bool</span> tx_ready = !(status &amp; <a class="code hl_variable" href="classPl011.html#a5320acc79dd686839f46ae890d3c7932">Pl011::kFRTxFIFO</a>);</div>
<div class="ttc" id="atests_2integration__test_2aarch64__minimal_2main_8cpp_html_aa7ab943a365e8ef56f90c192e7777452"><div class="ttname"><a href="tests_2integration__test_2aarch64__minimal_2main_8cpp.html#aa7ab943a365e8ef56f90c192e7777452">uart</a></div><div class="ttdeci">volatile uint8_t * uart</div><div class="ttdoc">TODO: Add description.</div><div class="ttdef"><b>Definition</b> <a href="tests_2integration__test_2aarch64__minimal_2main_8cpp_source.html#l00010">main.cpp:10</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md142"></a>
错误处理</h2>
<div class="fragment"><div class="line"><span class="comment">// 错误状态检查</span></div>
<div class="line">uint32_t status = io::In&lt;uint32_t&gt;(base_addr_ + kRegRSRECR);</div>
<div class="line"><span class="keywordflow">if</span> (status &amp; 0x0F) {  <span class="comment">// 检查错误位</span></div>
<div class="line">  <span class="comment">// 清除错误</span></div>
<div class="line">  io::Out&lt;uint32_t&gt;(base_addr_ + kRegRSRECR, 0);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
